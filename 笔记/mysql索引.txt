InnoDB索引采用b-tree
索引根据根节点一层一层往下寻找，最后到叶子节点，叶子节点储存了指向数据的指针（所有查询最后都会到叶子节点），对于索引，索引里储存有查询列的值，所以当要查的数据只有索引列时，
是不会在通过聚簇索引查所有数据的，可以直接取出。



如果创建多字段索引（即一个索引由多个字段组成create index index_name on employee(name,department_id，employee_id），索引有效的查询是：
1、全值匹配，即通过name和department_id两个列来查。
2、匹配最左前缀，即通过最左边的索引开始，如可以用name和department来查，不许name在前，department在后
3、匹配列前缀，及模糊查询name，也只使用第一个索引列name。
4、匹配到第一列，再模糊到第二列，如name精确查询，但是department模糊查也会走索引。
5、只访问索引的查询
6、模糊查询是匹配后面的则会通过索引 如（name like 'ou%'）匹配前面的则不会走索引如 （name lieke '%ou'）

通过实验发现，不是最前缀也会过索引，但是必须过前缀，如select * from employee where department=1 and name=‘’会走name索引，然后再通过where其他条件来查询
但是如果是 select * from employee department则不会走索引。

前缀索引
alter table employee add key name(4) //一般需要对很长的varchar或者text或者blog等长字段建立前缀索引。
方法 首先通过自己测试多长合适 如select count(*) as cn,left(name,1) as pre from employee group by name order by cn;
找到合适长度再建立索引  alter table student add key (name(5))

多列索引  
上面的实例就是多列索引，在选择索引顺序时，如果不考虑排序的情况的话，将选择型高的列放在前面是最好的。有时可以依赖查询结果值来优化，比如name=‘欧根’有10条
但是age=22的有200000条，就可以把name字段放在多列索引前面，但这样可能对其他字段值查询不公平，因为是按照特定条件来的，可能会带来影响，所以不推荐。一般按经验法则来
选择  具体做法  select  count(distinct name)/count(*) as name_sele,count(distinct age)/count(*) as age_sele from employee,根据值越大，谁就在前面，因为不同的多，所以重复型小

聚簇索引
InnoDB中，主键就是聚簇索引，如果没有主键，那么它会选择一个唯一非空的索引作为聚簇索引，如果没有这样的索引，那么会隐式的生成一个主键来作为聚簇索引。聚簇索引，索引和数
据行放在一块，所以他的优点就是，要比普通的非聚簇索引快，因为它不用额外去取数据。//还有个优点不理解，是使用覆盖索引扫描的查询可以直接使用叶节点的主键值 
缺点
1、如果数据都在内存中，聚簇索引的磁盘io就不会有了，所以意义就没有了。2、更新聚簇索引的代价大，因为更新会是每行数据随着聚簇索引变更位置。3、聚簇索引可能会导致全表扫描变慢。
可能是因为数据量大。4、并且对于非聚簇索引大小要比想象大，因为里面还存在有主键列。（索引查询也就是说通过索引查到主键列，再通过主键聚簇索引获得里面的数据，相当于二级索引中存的是主键值，所
以二级查找需要两次。）5、聚簇索引插入慢，按主键顺序的插入的话速度快（因为在插入数据时，是要按主键的顺序插入的，所以在插入乱序的时候，可能需要插入到前面页中，导致后面的数据行需要移动，
当插入一个满页中，innodb还会分为2页来储存，导致空间浪费，非聚集索引只会维护自己的顺序，因为里面没有行数据）。所以在InnoDB中千万别用UUID作为主键。

MyISAM与InnoDB不同
MyISAM主键其实和InnoDB的非主键索引没什么不同，不同的是它的叶子节点储存的是行号（MyISAM数据储存是按插入先后顺序来的，但是会加个行号），通过行号找到数据。所以MyISAM在插入数据会比
InnoDB快很多。查询也是，InnoDB需要查两次(即先通过索引，再通过主键)

覆盖索引
相当于通过where查询，查询条件也就是我们需要返回的数据并且是索引列，所以我们就不需要再去通过索引再去访问数据表所有数据，可以直接返回，极大提高了效率。要成为覆盖索引
首先必须的存有值，而hash索引不存在值，储存的是hash值和数据行指针，所以是没有列数据的，所以不能作为覆盖索引。